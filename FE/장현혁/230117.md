# 리덕스란?

## 리덕스

JavaScript 애플리케이션을 위한 상태 관리 라이브러리

## Props vs State

### Props

1. properties의 줄임말
2. Props는 구성 요소가 서로 통신하는 방법
3. 부모에서 자식으로
4. 값을 변경하려면 부모의 내부 상태를 변경해야 한다.

```js
<ChatMessages
  messages={messages}
  currentMember={member}
/>
```

### State

1. component 안에서 데이터를 전달하는 방식

   - ex. 검색 창에 글을 입력할 때 글이 변하는 것은 state를 바꾸는 것

2. State는 mutable(변하기 쉽다)
3. State가 변하면 re-render 된다.

```js
state = {
  message: "",
  attachFile: undefined,
  openMenu: false,
}
```
**그래서 Redux는 State를 관리하는 것**

## Redux 데이터 Flow(strict unidirectional data flow)

![image](https://user-images.githubusercontent.com/109258146/212611866-2f0b3951-08b5-4451-9937-10f551bb39fe.png)

> Action

- Action은 간단한 JavaScript 객체. 여기에는 우리가 수행하는 작업의 유형을 지정하는 "type" 속성이 있으며 선택적으로 redux 저장소에 일부 데이터를 보내는 데 사용되는 "payload" 속성을 가질 수도 있습니다.

```js
{ type: "LIKE_ARTICLE", articleId: 42}
{ type: "FETCH_USER_SUCCESS", response: { id: 3, name: "Mary"} }
{ type: "ADD_TODO", text: "Read the Redux docs." }
```

> Reducer

- 리듀서는 애플리케이션 상태의 변경 사항을 결정하고 업데이트 된 상태를 반환하는 함수입니다. 그들은 인수로 조치를 취하고 store 내부의 상태를 업데이트 합니다.

```js
{previousState, action} => nextState
// 이전 State와 action object를 받은 후에 nextState을 return 한다.
```

### Reducer는 pure function이기에 reducer 내부에서 하지 말아야 할 것들

- Mutate its arguments
- Perform side effects like API calls and routing transitions;
- Call non-pure functions, e.g. Date.now() or Math.random().

> Redux Store

- 이들을 하나로 모으는 객체 저장소는 애플리케이션의 전체 상태 트리를 보유합니다. 내부 상태를 변경하는 유일한 방법은 해당 상태에 대한 Action을 전달하는 것입니다. Redux Store는 클래스가 아닙니다. 몇 가지 Methods가 있는 객체일 뿐입니다.

### <Provider/> is the higher-order component provided by React Redux that lets you bind Redux to React

---

# Redux Provider

## Provider란?

<Provider\> 구성 요소는 Redux Store 저장소에 엑세스 해야 하는 모든 중첩 요소에서 Redux Store 저장소를 사용할 수 있도록 합니다.

React Redux 앱의 모든 React 구성 요소는 저장소에 연결할 수 있으므로 대부분의 응용 프로그램은 전체 앱의 구성 요소 트리가 내부에 있는 최상위 수준에서 <Provider\>를 렌더링 합니다.

그런 다음 Hooks 및 연결 API는 React의 컨텍스트 메커니즘을 통해 제공된 저장소 인스턴스에 엑세스할 수 있습니다.

## Provider를 렌더링

React Redux 앱의 모든 React 구성 요소는 저장소에 연결할 수 있으므로 대부분의 응용 프로그램은 전체 앱의 구성 요소 트리가 내부에 있는 최상위 수준에서 <Provider\>를 렌더링합니다.

```tsx
// index.tsx

import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';
import { createStore } from "redux";
import rootReducer from "./reducers";
import { Provider } from "react-redux";

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);

const store = createStore(rootReducer);

store.dispatch({
  type: "ADD_TODO",
  text: "Use Redux"
})
console.log(store.getState())

const render = () => root.render(
  <React.StrictMode>
    <Provider store={store}>
      <App
        onIncrement={() => store.dispatch({ type: "INCREMENT" })}
        onDecrement={() => store.dispatch({ type: "DECREMENT"})}
      />
    </Provider>
  </React.StrictMode>
);

render();

store.subscribe(render);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
```

## Todo UI 생성

```tsx
// App.tsx

import React, { useState } from 'react';
import './App.css';

type Props = {
  value: any;
  onIncrement: () => void;
  onDecrement: () => void;
}

function App({ value, onIncrement, onDecrement }: Props) {
  const [todoValue, setTodoValue] = useState("")
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setTodoValue(e.target.value)
  }

  const addTodo = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setTodoValue("");
  }

  return (
    <div className="App">
      {/* Clicked: {value} times */}
      <button onClick={onIncrement}>
        +
      </button>
      <button onClick={onDecrement}>
        -
      </button>

      <form onSubmit={addTodo}>
        <input type="text" value={todoValue} onChange={handleChange}/>
        <input type="submit" />
      </form>
    </div>
  );
}

export default App;
```

--- 

# useSelector & useDispatch

## Provider로 둘러 쌓인 컴포넌트에서 store 접근

리액트에 Hooks가 있듯이 리덕스에도 Hooks가 있는데 그게 바로 useSelector와 useDispatch입니다. 이 두개를 이용해서 provider로 둘러 쌓인 컴포넌트에서 store에 접근이 가능합니다.

## useSelector

useSelector Hooks를 이용해서 스토어의 값을 가져올 수 있습니다.

```tsx
const result: any = useSelector(selector: Function, equalityFn?: Function)
```

```tsx
// App.tsx
const counter = useSelector((state) => state.counter);
```
에러 발생.

### 해결 방법

1. Root Reducer에 RootState 타입을 생성하기

```tsx
// reducers/index.tsx

export default rootReducer;

export type RootState = ReturnType<typeof rootReducer>;
```

2. 생성한 RootState를 State 객체에 제공하기

```tsx
// App.tsx

  const counter = useSelector((state: RootState) => state.counter);
  const todos: string[] = useSelector((state: RootState) => state.todos)
```

## useDispatch

store에 있는 dispatch 함수에 접근하는 hooks 입니다.

---

# Redux Middleware

## Redux Middleware 란?

Redux Middleware는 액션을 dispatch 전달하고 리듀서에 도달하는 순간 사이에 사전에 지정된 작업을 실행할 수 있게 해주는 중간자입니다.

로깅, 충돌 보고, 비동기 API와 통신, 라우팅 등을 위해 Redux Middleware를 사용합니다.

UI 에서 Action 을 전달 -> dispatch 로 전달 -> 도착하기 전에 middlware에서 api를 보내고 -> response 를 받고 reducer에 전달

## Redux logging middleware 생성하기

```tsx
// index.tsx

const loggerMiddleware = (store: any) => (next: any) => (action: any) => {
  console.log("store", store)
  console.log("action", action)
  next(action);
}

const middleware = applyMiddleware(loggerMiddleware)
const store = createStore(rootReducer, middleware);
```

---

# Redux Thunk

## Redux Thunk 란?

리덕스를 사용하는 앱에서 비동기 작업을 할 때 많이 사용하는 방법이 redux-thunk 입니다. 이것도 앞서 만들어본 logger 미들웨어 처럼 리덕스 미들웨어이며, 리덕스를 개발한 Dan Abramov가 만들었습니다.

## Thunk 용어는?

`thunk`라는 단어는 `일부 지연된 작업을 수행하는 코드 조각`을 위미하는 프로그래밍 용어입니다. 지금 일부 논리(logic)을 실행하는 대신 나중에 작업을 수행하는 데 사용할 수 있는 함수 본문이나 코드를 작성할 수 있습니다.

```tsx
// calculation of 1 + 2 is immediate
// x === 3
let x = 1 + 2

// calculation of 1 + 2 is delayed
// foo can be called later to perform the calculation
// foo is a thunk!
let foo = () => 1 + 2
```

## 비동기 작업을 해야할 때는?

여러 경우가 있지만 서버에 요청을 보내서 데이터를 가져올 때 주로 비동기 요청을 보냅니다.

비동기로 https://jsonplaceholder.typicode.com에 요청을 보내면 Dummy 데이터를 받을 수 있습니다. 이 더미 데이터로 포스트를 만들어 보겠습니다.

### axios 다운로드 및 posts 리듀서 생성

```tsx
// reducers/posts.tsx

enum ActionType {
  FETCH_POSTS = "FETCH_POSTS",
  DELETE_POSTS = "DELETE_POSTS",
}

interface Post {
  userId: number;
  id: number;
  title: string;
}

interface Action {
  type: ActionType;
  payload: Post[]
}

const posts = (state = [], action: Action) => {
  switch (action.type) {
    case "FETCH_POSTS":
      return [...state, ...action.payload]
    default:
      return state;
  }
};

export default posts;
```
```tsx
// reducers/index.tsx

const rootReducer = combineReducers({
  counter,
  todos,
  posts
})
```

### posts 데이터를 위한 요청 보내기

```tsx
// App.tsx

function App({ value, onIncrement, onDecrement }: Props) {
  const dispatch = useDispatch();
  const counter = useSelector((state: RootState) => state.counter);
  const todos: string[] = useSelector((state: RootState) => state.todos)
  const [todoValue, setTodoValue] = useState("")

  useEffect(() => {
    dispatch(fetchPosts())
  }, [dispatch])

  const fetchPosts = () : any => {
    return async function fetchPostsThunk(dispatch: any, getState: any) {
      const response = await axios.get("https://jsonplaceholder.typicode.com/posts")
      dispatch({ type: "FETCH_POSTS", payload: response.data })
    }
```

### 에러가 나는 이유?

원래 Action은 객체여야 하는데 현재는 함수를 dispatch 하고 있습니다.그러기 때문에 나는 에러입니다. 그래서 함수를 dispatch 할 수 있게 해주는 Redux-Thunk 미들웨어를 설치해서 사용해보겠습니다.

```bash
npm install redux-thunk --save
```

### redux-thunk 설치

### redux-thunk 적용

```tsx
// index.tsx
import thunk from "redux-thunk"

const middleware = applyMiddleware(thunk, loggerMiddleware)
```

![image](https://user-images.githubusercontent.com/109258146/212736794-0ec42bc7-886a-4e8f-95ba-8caf8ace1e00.png)

### posts 데이터 화면에 표출

```tsx
// App.tsx

interface Post {
  userId: number
  id: number
  title: string
}

const posts: Post[] = useSelector((state: RootState) => state.posts);
```

## actions 들은 actions 폴더로 따로 분리

```tsx
// actions/posts.tsx

import axios from "axios";

export const fetchPosts = () : any => {
  return async function fetchPostsThunk(dispatch: any, getState: any) {
    const response = await axios.get("https://jsonplaceholder.typicode.com/posts")
    dispatch({ type: "FETCH_POSTS", payload: response.data })
  }
};

```

### modern ES2015 형태로 변경

```tsx
// actions/posts.tsx

export const getchPosts = () : any => async (dispatch: any, getState: any) => {
  const response = await axios.get("https://jsonplaceholder.typicode.com/posts")
  dispatch({ type: "FETCH_POSTS", payload: response.data })
};
```

## 결론

redux thunk를 사용함으로써 액션 생성자가 그저 하나의 액션 객체를 생성할 뿐 아니라 그 내부 안에서 여러 가지 작업도 할 수 있게 만들어 줍니다.

---

# Redux Toolkit

## Redux Toolkit

Redux Toolkit은 Redux 로직을 작성하기 위한 공식 권장 접근 방식입니다. Redux 코어를 둘러싸고 있으며 Redux 앱을 빌드하는 데 필수적이라고 생각하는 패키지와 기능이 포함되어 있습니다. Redux Toolkit은 제안된 모범 사례를 기반으로 하여 대부분의 Redux 작업을 단순화하고 일반적인 실수를 방지하고 Redux 애플리케이션을 더 쉽게 작성할 수 있도록 합니다.

### Redux Toolkit으로 만들어진 카운터 앱 살펴보기

```bash
npx create-react-app my-app --template redux-typescript
```

### Store 생성하기

craeteStore()가 아닌 app 폴더 안에 store가 있다.

### React에 Redux 스토어 제공

저장소가 생성되면 src/index.js에서 애플리케이션 주위에 React-Redux<Provider\>를 배치하여 React 구성요소에서 사용할 수 있도록 할 수 있습니다. 방금 만든 Redux 저장소를 가져오고 주위에 <Provider\>를 배치하고 저장소를 prop으로 전달합니다.

### Redux State Slice 생성

src/features/counter/counterSlice.js라는 새 파일을 추가합니다. 해당 파일에서 Redux Toolkit의 createSlice API를 가져옵니다.

Redux Toolkit을 사용하면 리듀서에서 `변경` 로직을 작성할 수 있습니다. 그것은 immer 라이브러리를 사용하기 때문에 실제로 상태를 변경하지 않습니다. `초안(draft) 상태` 에 대한 변경 사항을 감지하고 이러한 변경 사항을 기반으로 완전히 새로운 불변(immutable) 상태를 생성합니다.

### Reducer

Reducer는 애플리케이션 상태의 변경 사항을 결정하고 업데이트 된 상태를 반환하는 함수입니다. 그들은 인수로 조치를 취하고 store 내부의 상태를 업데이트합니다.

### 스토어에 Slice Reducer 추가

다음으로 카운터 슬라이스에서 리듀서 함수를 가져와서 스토어 함수에 추가해야 합니다. 리듀서 매개변수 내부에 필드를 정의함으로써 스토어이 이 슬라이스 리듀서 함수를 사용하여 해당 상태에 대한 모든 업데이트를 처리하도록 지시합니다.

### React 컴포넌트에서 Redux State 및 Actions 사용

- useSelector : useSelector 를 사용하여 저장소에서 데이터를 읽고
- useDispatch : useDispatch 를 사용하여 Action을 전달할 수 있습니다.

```tsx
export function Counter() {
  const count = useSelector((state: RootState) => state.counter.value)
  const dispatch = useDispatch()
}
```

---

1. configureStore를 사용하여 Redux 저장소 만들기

   - configureStore는 reducer 함수를 명명된 인수로 받아들입니다.
   - configureStore는 좋은 기본 설정으로 저장소를 자동으로 설정합니다.

2. React 애플리케이션 구성 요소에 Redux 저장소 제공

   - 주위에 React-Redux <Provider\> 구성 요소를 배치하십시오
   - Redux 저장소를 `<Provider store={store}>`로 전달합니다.

3. createSlice로 Redux 슬라이스 리듀서 생성

   - 문자열 이름, 초기 상태 및 명명된 리듀서 함수로 createSlice 호출
   - Reducer function은 Immer를 이용하여 상태를 mutate 할 수 있습니다.
   - 생성된 슬라이스 리듀서 및 액션 생성기 내보내기

4. React 구성 요소에서 React-Redux useSelector/useDispatch 후크 사용

   - useSelector Hooks를 사용하여 저장소에서 데이터 읽기
   - useDispatch Hooks를 사용하여 디스패치 함수를 가져오고 필요에 따라 작업을 디스패치 합니다.